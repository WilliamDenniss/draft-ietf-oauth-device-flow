<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.26 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc strict="yes"?>
<?rfc toc="yes"?>
<?rfc tocdepth="2"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="no"?>
<?rfc subcompact="no"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>

<rfc ipr="trust200902" docName="draft-ietf-oauth-device-flow-00" category="std">

  <front>
  <title abbrev="OAuth 2.0 Device Flow">OAuth 2.0 Device Flow</title>   

   <author fullname="William Denniss" initials="W."
            surname="Denniss">
      <organization>Google</organization>

      <address>
        <postal>
          <street>1600 Amphitheatre Pkwy</street>
          <city>Mountain View</city>
          <region>CA</region>
          <code>94043</code>
          <country>USA</country>
        </postal>
        <phone>+1 650-253-0000</phone>
        <facsimile/>
        <email>wdenniss@google.com</email>
        <uri>http://google.com/</uri>
      </address>
    </author>

    <author initials="S." surname="Myrseth" fullname="Stein Myrseth">
      <organization>Forgerock</organization>
      <address>
        <postal>
          <street>Lysaker torg 2</street>
          <city>Lysaker</city>
          <code>1366</code>
          <country>NORWAY</country>
        </postal>
        <email>stein.myrseth@forgerock.com</email>
      </address>
    </author>


    <author fullname="John Bradley" initials="J." surname="Bradley">
      <organization abbrev="Ping Identity">Ping Identity</organization>
      <address>
	<email>ve7jtb@ve7jtb.com</email>
  <uri>http://www.thread-safe.com/</uri>
      </address>
    </author>

    <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
      <organization abbrev="Microsoft">Microsoft</organization>
      <address>
        <email>mbj@microsoft.com</email>
        <uri>http://self-issued.info/</uri>
      </address>
    </author>


    <author initials="H." surname="Tschofenig" fullname="Hannes Tschofenig">
      <organization>ARM Limited</organization>
      <address>
        <postal>
          <street></street>
          <city></city>
          <code></code>
          <country>Austria</country>
        </postal>
        <phone></phone>
        <email>Hannes.Tschofenig@gmx.net</email>
        <uri>http://www.tschofenig.priv.at</uri>
      </address>
    </author>


    <date year="2016" month="February" day="17"/>

    <area>Security Area</area>
    <workgroup>OAuth</workgroup>
    <keyword>OAuth</keyword>
    <keyword>Security</keyword>
    <keyword>Authorization</keyword>
    <keyword>IoT</keyword>
    <keyword>Internet of Things</keyword>
    <keyword>Smart Objects</keyword>

    <abstract>

<t>The device flow is suitable for OAuth 2.0 clients executing on
   devices which do not have an easy data-entry method (e.g., game
   consoles, TVs, picture frames, and media hubs), but where the end-user has separate access
   to a user-agent on another computer or device (e.g., desktop computer, a
   laptop, a smart phone, or a tablet).</t>

<t>Note: This version of the document is a continuation of an earlier, long
expired draft. The content of the expired draft has been copied almost
unmodified. The goal of the work on this document is to capture deployment 
experience.</t> 
    </abstract>

  </front>
  <middle>


<section anchor="introduction" title="Introduction">

<t>   The device flow is suitable for clients executing on devices which
   do not have an easy data-entry method and where the client is 
incapable of receiving incoming requests from
   the authorization server (incapable of acting as an HTTP server).
</t> 

<t>
   Instead of interacting with the end-user's user-agent, the client
   instructs the end-user to use another computer or device and connect
   to the authorization server to approve the access request.  Since the
   client cannot receive incoming requests, it polls the authorization
   server repeatedly until the end-user completes the approval process.</t> 

<t>Note that this device flow does not utilize the client secret.</t>

<t><figure title="Device Flow." anchor="overview"><artwork><![CDATA[
   +----------+                                +----------------+
   |          |>---(A)-- Client Identifier --->|                |
   |          |                                |                |
   |          |<---(B)-- Verification Code, --<|                |
   |          |              User Code,        |                |
   |          |         & Verification URI     |                |
   |  Device  |                                |                |
   |  Client  |         Client Identifier &    |                |
   |          |>---(E)-- Verification Code --->|                |
   |          |    ...                         |                |
   |          |>---(E)--->                     |                |
   |          |                                |  Authorization |
   |          |<---(F)-- Access Token --------<|     Server     |
   +----------+  (w/ Optional Refresh Token)   |                |
         v                                     |                |
         :                                     |                |
        (C) User Code & Verification URI       |                |
         :                                     |                |
         v                                     |                |
   +----------+                                |                |
   | End-user |                                |                |
   |    at    |<---(D)-- User authenticates -->|                |
   |  Browser |                                |                |
   +----------+                                +----------------+
]]></artwork></figure>
</t>

<t>The device flow illustrated in <xref target="overview"/> includes the following steps:
<list style="empty"> 

<t>(A) The client requests access from the authorization server and
        includes its client identifier in the request.</t>

<t>(B)  The authorization server issues a verification code, an end-user
        code, and provides the end-user verification URI.</t>

<t>(C)  The client instructs the end-user to use its user-agent
        (elsewhere) and visit the provided end-user verification URI.
        The client provides the end-user with the end-user code to enter
        in order to grant access.</t>

<t>(D)  The authorization server authenticates the end-user (via the
        user-agent) and prompts the end-user to grant the client's
        access request.  If the end-user agrees to the client's access
        request, the end-user enters the end-user code provided by the
        client.  The authorization server validates the end-user code
        provided by the end-user.</t>

<t>(E)  While the end-user authorizes (or denies) the client's request
        (D), the client repeatedly polls the authorization server to
        find out if the end-user completed the end-user authorization
        step.  The client includes the verification code and its client
        identifier.</t>

<t>(F)  Assuming the end-user granted access, the authorization server
        validates the verification code provided by the client and
        responds back with the access token.</t>
</list> 
</t> 

</section>



<section anchor="terminology" title="Terminology">

<t>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,
“SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and
“OPTIONAL” in this document are to be interpreted as described in <xref target="RFC2119"/>.</t>

<t><list style="hanging"> 

<t hangText="Device Endpoint:"><vspace blankLines="1"/>
         The authorization server's endpoint capable of issuing
         verification codes, user codes, and verification URLs.
</t> 

<t hangText="Device Verification Code:"><vspace blankLines="1"/>
         A short-lived token representing an authorization session.</t>

<t hangText="End-User Verification Code:"><vspace blankLines="1"/>
         A short-lived token which the device displays to the end user,
         is entered by the end-user on the authorization sever, and is
         thus used to bind the device to the end-user.
</t> 
</list> 
</t> 

</section>



<section title="Specification"> 



<section title="Client Requests Authorization">

<t>The client initiates the flow by requesting a set of verification
   codes from the authorization server by making an HTTP "POST" request
   to the device endpoint.  The client constructs a request URI by
   adding the following parameters to the request:</t>

<t><list style="hanging"> 
<t hangText="response_type:"><vspace blankLines="1"/>
         REQUIRED.  The parameter value MUST be set to "device_code".</t> 

<t hangText="client_id:"><vspace blankLines="1"/>
         REQUIRED.  The client identifier as described in Section 2.2 of
         <xref target="RFC6749"/>.</t> 

<t hangText="scope:"> <vspace blankLines="1"/>
         OPTIONAL.  The scope of the access request as described by
         Section 3.3 of <xref target="RFC6749"/>.</t> 
</list> 
</t> 

<t>For example, the client makes the following HTTPS request (line
   breaks are for display purposes only):
<figure><artwork><![CDATA[
   POST /token HTTP/1.1
   Host: server.example.com
   Content-Type: application/x-www-form-urlencoded

   response_type=device_code&client_id=s6BhdRkqt3
]]></artwork></figure>
</t> 

<t>
   In response, the authorization server generates a verification code
   and an end-user code and includes them in the HTTP response body
   using the "application/json" format with a 200 status code (OK).  The
   response contains the following parameters:</t>

<t><list style="hanging"> 

<t hangText="device_code"><vspace blankLines="1"/>
 
         REQUIRED.  The verification code.</t>

<t hangText="user_code"> <vspace blankLines="1"/>
         REQUIRED.  The end-user verification code.</t>

<t hangText="verification_uri"> <vspace blankLines="1"/>
         REQUIRED.  The end-user verification URI on the authorization
         server.  The URI should be short and easy to remember as end-
         users will be asked to manually type it into their user-agent.</t>

<t hangText="expires_in"> <vspace blankLines="1"/>
         OPTIONAL.  The duration in seconds of the verification code
         lifetime.</t>

<t hangText="interval"> <vspace blankLines="1"/>
         OPTIONAL.  The minimum amount of time in seconds that the
         client SHOULD wait between polling requests to the token
         endpoint.</t> 
</list> 
</t> 

<t>For example:
<figure><artwork><![CDATA[
   HTTP/1.1 200 OK
   Content-Type: application/json
   Cache-Control: no-store

   {
     "device_code":"74tq5miHKB",
     "user_code":"94248",
     "verification_uri":"http://www.example.com/device",
     "interval"=5
   }
]]></artwork></figure>
</t> 

<t>   The client displays the end-user code and the end-user verification
   URI to the end-user, and instructs the end-user to visit the URI
   using a user-agent and enter the end-user code.</t>

<t>   The end-user manually types the provided verification URI and
   authenticates with the authorization server.  The authorization
   server prompts the end-user to authorize the client's request by
   entering the end-user code provided by the client.  Once the end-user
   approves or denies the request, the authorization server informs the
   end-user to return to the device for further instructions.</t> 


</section> 


<section title="Client Requests Access Token"> 

<t>   Since the client is unable to receive incoming requests from the
   authorization server, it polls the authorization server repeatedly
   until the end-user grants or denies the request, or the verification
   code expires.</t>

<t>   The client makes the following request at an arbitrary but reasonable
   interval which MUST NOT exceed the minimum interval rate provided by
   the authorization server (if present via the "interval" parameter).
   Alternatively, the client MAY provide a user interface for the end-
   user to manually inform it when authorization was granted.</t>

<t>   The client requests an access token by making an HTTP "POST" request
   to the token endpoint as described in Section 4.1.1 of
   <xref target="RFC6749"/> .  The "redirect_uri" parameter is NOT REQUIRED as
   part of this request.</t>

</section> 

<section title="Additional Error Responses">

<t>   The following error responses are defined in addition to those within
   Section 4.2.2.1. of <xref target="RFC6749"/>: 

<list style="hanging"> 

<t hangText="authorization_pending"> <vspace blankLines="1"/>

         The authorization request is still pending as the end-user
         hasn't yet visited the authorization server and entered their
         verification code.</t>

<t hangText="slow_down"> <vspace blankLines="1"/>
         The client is polling too quickly and should back off at a
         reasonable rate.</t>

</list> 
</t>


</section> 

</section> 


<section title="Contributors">

<t>The -00 version of this document is based on a previous 
edited by David Recordon and Brent Goldman. The content of that document 
was initially part of the OAuth 2.0 protocol specificaiton but was later 
removed due to the lack of sufficient deployment expertise at that time.
We would therefore also like to thank the OAuth working group for their
work on this document around 2010.</t>

</section>


<section title="Acknowledgements">

<t>Add your name here.</t>

</section>


<section title="Security Considerations">

<t>TBD</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>
      <?rfc include="reference.RFC.6749"?>
      <?rfc include="reference.RFC.2119"?>
    </references>

  </back>
</rfc>

