<?xml version="1.0" encoding="US-ASCII"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.26 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="4"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc ipr="trust200902" docName="draft-ietf-oauth-device-flow-04" category="std">

  <front>
  <title abbrev="OAuth 2.0 Device Flow">OAuth 2.0 for Browserless and Input Constrained Devices</title>   

   <author fullname="William Denniss" initials="W."
            surname="Denniss">
      <organization>Google</organization>

      <address>
        <postal>
          <street>1600 Amphitheatre Pkwy</street>
          <city>Mountain View</city>
          <region>CA</region>
          <code>94043</code>
          <country>USA</country>
        </postal>
        <facsimile/>
        <email>wdenniss@google.com</email>
        <uri>http://wdenniss.com/device-flow</uri>
      </address>
    </author>

    <author initials="S." surname="Myrseth" fullname="Stein Myrseth">
      <organization>ForgeRock</organization>
      <address>
        <postal>
          <street>Lysaker torg 2</street>
          <city>Lysaker</city>
          <code>1366</code>
          <country>NORWAY</country>
        </postal>
        <email>stein.myrseth@forgerock.com</email>
      </address>
    </author>

    <author fullname="John Bradley" initials="J." surname="Bradley">
      <organization abbrev="Ping Identity">Ping Identity</organization>
      <address>
        <email>ve7jtb@ve7jtb.com</email>
        <uri>http://www.thread-safe.com/</uri>
      </address>
    </author>

    <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
      <organization abbrev="Microsoft">Microsoft</organization>
      <address>
        <email>mbj@microsoft.com</email>
        <uri>http://self-issued.info/</uri>
      </address>
    </author>


    <author initials="H." surname="Tschofenig" fullname="Hannes Tschofenig">
      <organization>ARM Limited</organization>
      <address>
        <postal>
          <street></street>
          <city></city>
          <code></code>
          <country>Austria</country>
        </postal>
        <phone></phone>
        <email>Hannes.Tschofenig@gmx.net</email>
        <uri>http://www.tschofenig.priv.at</uri>
      </address>
    </author>


    <date year="2017" month="February" day="20"/>

    <area>Security Area</area>
    <workgroup>OAuth</workgroup>
    <keyword>OAuth</keyword>
    <keyword>Security</keyword>
    <keyword>Authorization</keyword>
    <keyword>IoT</keyword>
    <keyword>Internet of Things</keyword>
    <keyword>Smart Objects</keyword>

    <abstract>
      <t>
        This OAuth 2.0 authorization flow for browserless and input constrained
        devices, often referred to as the device flow, enables OAuth clients to
        request user authorization from devices that have an internet
        connection, but don't have an easy input method (such as a smart TV,
        media console, picture frame, or printer), or lack a suitable browser
        for a more traditional OAuth flow. This authorization flow instructs the
        user to action the authorization request on a secondary device, such as
        a smartphone. There is no requirement communication between the
        constrained device and the user's secondary device.
      </t>
    </abstract>

  </front>
  <middle>

    <section anchor="Introduction" title="Introduction">

      <t>
        This OAuth 2.0 protocol flow for browserless and input constrained
        devices, often referred to as the device flow, enables OAuth clients to
        request user authorization from devices that have an internet
        connection, but don't have an easy input method (such as a smart TV,
        media console, picture frame, or printer), or lack a suitable browser
        for a more traditional OAuth flow. This authorization flow instructs the
        user to action the authorization request on a secondary device, such as
        a smartphone.
      </t>

      <t>
        The device flow is not intended to replace browser-based OAuth in native
        apps on capable devices (like smartphones), those apps should follow
        the practices specified in OAuth 2.0 for Native Apps
        <xref target="I-D.ietf-oauth-native-apps">OAuth 2.0 for Native Apps</xref>.
      </t>

      <t>
        The only requirements to use this flow are that the device is connected
        to the internet, and able to make outbound HTTPS requests, be able to
        display or otherwise communicate a URI and code sequence to the user,
        and that the user has a secondary device (e.g. personal computer or
        smartphone) from which to process the request. There is no requirement
        for two-way communication between the oauth client and the user-agent,
        enabling a broad range of use-cases.
      </t>

      <t>
        Instead of interacting with the end-user's user-agent, the client
        instructs the end-user to use another computer or device and connect
        to the authorization server to approve the access request.  Since the
        client cannot receive incoming requests, it polls the authorization
        server repeatedly until the end-user completes the approval process.
      </t> 

      <t><figure title="Device Flow." anchor="Overview"><artwork><![CDATA[
   +----------+                                +----------------+
   |          |>---(A)-- Client Identifier --->|                |
   |          |                                |                |
   |          |<---(B)-- Verification Code, --<|                |
   |          |              User Code,        |                |
   |          |         & Verification URI     |                |
   |  Device  |                                |                |
   |  Client  |         Client Identifier &    |                |
   |          |>---(E)-- Verification Code --->|                |
   |          |    polling...                  |                |
   |          |>---(E)-- Verification Code --->|                |
   |          |                                |  Authorization |
   |          |<---(F)-- Access Token --------<|     Server     |
   +----------+  (w/ Optional Refresh Token)   |                |
         v                                     |                |
         :                                     |                |
        (C) User Code & Verification URI       |                |
         :                                     |                |
         v                                     |                |
   +----------+                                |                |
   | End-user |                                |                |
   |    at    |<---(D)-- User authenticates -->|                |
   |  Browser |                                |                |
   +----------+                                +----------------+
]]></artwork></figure>
      </t>

      <t>
	The device flow illustrated in <xref target="Overview"/> includes the following steps:
	<list style="empty"> 

	  <t>(A) The client requests access from the authorization server and
	  includes its client identifier in the request.</t>

	  <t>(B)  The authorization server issues a verification code, an end-user
	  code, and provides the end-user verification URI.</t>

	  <t>(C)  The client instructs the end-user to use its user-agent
	  (elsewhere) and visit the provided end-user verification URI.
	  The client provides the end-user with the end-user code to enter
	  in order to grant access.</t>

	  <t>(D)  The authorization server authenticates the end-user (via the
	  user-agent) and prompts the end-user to grant the client's
	  access request.  If the end-user agrees to the client's access
	  request, the end-user enters the end-user code provided by the
	  client.  The authorization server validates the end-user code
	  provided by the end-user.</t>

	  <t>(E)  While the end-user authorizes (or denies) the client's request
	  (D), the client repeatedly polls the authorization server to
	  find out if the end-user completed the end-user authorization
	  step.  The client includes the verification code and its client
	  identifier.</t>

	  <t>(F)  Assuming the end-user granted access, the authorization server
	  validates the verification code provided by the client and
	  responds back with the access token.</t>
	</list> 
      </t> 

    </section>

    <section anchor="Terminology" title="Terminology">

      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.</t>

      <t>
	<list style="hanging"> 

	  <t hangText="Device Endpoint:"><vspace blankLines="1"/>
	  The authorization server's endpoint capable of issuing
	  verification codes, user codes, and verification URLs.
	  </t> 

	  <t hangText="Device Verification Code:"><vspace blankLines="1"/>
	  A short-lived token representing an authorization session.</t>

	  <t hangText="End-User Verification Code:"><vspace blankLines="1"/>
	  A short-lived token which the device displays to the end user,
	  is entered by the end-user on the authorization server, and is
	  thus used to bind the device to the end-user.
	  </t> 
	</list> 
      </t> 

    </section>

    <section anchor="Protocol" title="Protocol"> 

      <section anchor="AuthorizationRequest" title="Device Authorization Request">

	<t>The client initiates the flow by requesting a set of verification
	codes from the authorization server by making an HTTP "POST" request
	to the device endpoint.  The client constructs a request URI by
	adding the following parameters to the request:</t>

	<t>
	  <list style="hanging"> 
	    <t hangText="response_type"><vspace blankLines="1"/>
	    REQUIRED.  The parameter value MUST be set to "device_code".</t> 

	    <t hangText="client_id"><vspace blankLines="1"/>
	    REQUIRED.  The client identifier as described in Section 2.2 of
	    <xref target="RFC6749"/>.</t> 

	    <t hangText="scope"> <vspace blankLines="1"/>
	    OPTIONAL.  The scope of the access request as described by
	    Section 3.3 of <xref target="RFC6749"/>.</t> 
	  </list> 
	</t> 

	<t>
	  For example, the client makes the following HTTPS request (line
	  breaks are for display purposes only):
	  <figure><artwork><![CDATA[
   POST /token HTTP/1.1
   Host: server.example.com
   Content-Type: application/x-www-form-urlencoded

   response_type=device_code&client_id=459691054427
]]></artwork></figure>
	</t> 

</section>

<section anchor="AuthorizationResponse" title="Device Authorization Response">

	<t>
	  In response, the authorization server generates a verification code
	  and an end-user code and includes them in the HTTP response body
	  using the "application/json" format with a 200 (OK) status code.  The
	  response contains the following parameters:
	</t>

	<t>
	  <list style="hanging"> 

	    <t hangText="device_code"><vspace blankLines="1"/>
	    
	    REQUIRED.  The verification code.</t>

	    <t hangText="user_code"> <vspace blankLines="1"/>
	    REQUIRED.  The end-user verification code.</t>

	    <t hangText="verification_uri"> <vspace blankLines="1"/>
	    REQUIRED.  The end-user verification URI on the authorization
	    server.  The URI should be short and easy to remember as end-
	    users will be asked to manually type it into their user-agent.</t>

	    <t hangText="expires_in"> <vspace blankLines="1"/>
	    OPTIONAL.  The duration in seconds of the verification code
	    lifetime.</t>

	    <t hangText="interval"> <vspace blankLines="1"/>
	    OPTIONAL.  The minimum amount of time in seconds that the
	    client SHOULD wait between polling requests to the token
	    endpoint.</t> 
	  </list> 
	</t> 

	<t>
	  For example:
	  <figure><artwork><![CDATA[
   HTTP/1.1 200 OK
   Content-Type: application/json
   Cache-Control: no-store

   {
     "device_code":"GMMhmHCXhWEzkobqIHGG_EnNYYsAkukHspeYUk9E8",
     "user_code":"WDJB-MJHT",
     "verification_uri":"https://www.example.com/device",
     "expires_in" : 1800,
     "interval": 5
   }
]]></artwork></figure>
	</t> 

</section> 

<section title="User Instruction" anchor="UserInstruction">

  <t>
    After receiving a successful Authorization Response, the client displays or
    otherwise communicates the <spanx style="verb">user_code</spanx> and the
    <spanx style="verb">verification_uri</spanx> to the end-user, and instructs
    the them to visit the URI in a user agent on a secondary device
    (for example, in browser on their mobile phone), and enter the user code.
  </t>
	
	<t>
	  The end-user navigates to the <spanx style="verb">verification_uri</spanx>
    and authenticates with the authorization server.  The authorization server
    prompts the end-user to identify the device authorization session by
    entering the <spanx style="verb">user_code</spanx> provided by the client.
    The authorization server SHOULD then inform the user about the action they
    are undertaking, and ask them to approve or deny the request. Once the user
    interaction is complete, the server informs the user to return to their
    device.
	</t>

  <t>
    During this user interaction, the device continuously polls the token
    endpoint, with the <spanx style="verb">device_code</spanx>, as detailed in
    <xref target="TokenRequest"/>, until the user completes the interaction,
    the code expires, or another error occurs.
  </t>

  <t>
    Authorization servers supporting this specification MUST implement a user
    interaction sequence that starts with the user navigating to
    <spanx style="verb">verification_uri</spanx> and continues with them
    supplying the <spanx style="verb">user_code</spanx> at some stage during
    the interaction. Other than that, the exact sequence and implementation of
    the user interaction is up to the authorization server, and is out of scope
    of this specification.
  </t>
  <t>
    Devices and authorization servers MAY negotiate an alternative code
    transmission and user interaction method in addition to the one described
    here. Such an alternative user interaction flow could obviate the need for a
    browser and manual input of the code, for example, by using Bluetooth to
    transmit the code to the authorization server's companion app. Such
    interaction methods can utilize this protocol, as ultimately, the user just
    needs to identify the authorization session to the authorization server,
    however user interaction other than via the
    <spanx style="verb">verification_uri</spanx> is outside the scope of this
    specification.
  </t>


</section> 


<section title="Device Access Token Request" anchor="TokenRequest"> 
  
  <t>
    After displaying instructions to the user, the client makes an Access Token
    Request to the token endpoint with a <spanx style="verb">grant_type</spanx> 
    of <spanx style="verb">urn:ietf:params:oauth:grant-type:device_code</spanx>.
    This is an extension grant type (as defined by Section 4.5 of
    <xref target="RFC6749"/>) with the following parameters:
  </t>

  <t>
  <list style="hanging"> 
    <t hangText="grant_type"><vspace blankLines="1"/>
          REQUIRED.  Value MUST be set to
          <spanx style="verb">urn:ietf:params:oauth:grant-type:device_code</spanx>.</t>

    <t hangText="device_code"> <vspace blankLines="1"/>
           REQUIRED.  The device verification code, <spanx style="verb">device_code</spanx> from the
           Device Authorization Response, defined in Section 3.2.</t>
 
 
  <t hangText="client_id"> <vspace blankLines="1"/>
           REQUIRED, if the client is not authenticating with the
           authorization server as described in Section 3.2.1. of 
           <xref target="RFC6749"/>.</t>

  </list> 
  </t> 

  <t>For example, the client makes the following HTTPS request (line
     breaks are for display purposes only):

  <figure><artwork><![CDATA[

   POST /token HTTP/1.1
   Host: server.example.com
   Content-Type: application/x-www-form-urlencoded

   grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Adevice_code
   &device_code=GMMhmHCXhWEzkobqIHGG_EnNYYsAkukHspeYUk9E8
   &client_id=459691054427

]]></artwork></figure>
  </t> 

  <t>
    If the client was issued client
    credentials (or assigned other authentication requirements), the
    client MUST authenticate with the authorization server as described
    in Section 3.2.1 of <xref target="RFC6749"/>. Note that there are security
    implications of statically distributed client credentials, see
    <xref target="NonConfidentialClient" />.
  </t>

  <t>
    The response to this request is defined in <xref target="TokenResponse" />.
    Unlike other OAuth grant types, it is expected for the client to try the
    Access Token Request repeatedly in a polling fashion, based on the error
    code in the response.
  </t>

</section> 

<section title="Device Access Token Response" anchor="TokenResponse"> 

  <t>If the user has approved the grant, the token endpoint responds with
  a success response defined in Section 5.1 of <xref target="RFC6749"/>,
  otherwise it responds with an error, as defined in Section 5.2 of 
  <xref target="RFC6749"/>. 
  </t>

  <t>In addition to the error codes defined in Section 5.2 of
    <xref target="RFC6749"/>, the following error codes
    are specific for the device flow: 

  <list style="hanging"> 

  <t hangText="authorization_pending"> <vspace blankLines="1"/>

           The authorization request is still pending as the end-user
           hasn't yet completed the User Interaction steps (<xref target="UserInstruction" />). The client should repeat
           the Access Token Request to the token endpoint.</t>

  <t hangText="slow_down"> <vspace blankLines="1"/>
           The client is polling too quickly and should back off at a
           reasonable rate.</t>

  <t hangText="expired_token"> <vspace blankLines="1"/>
           The <spanx style="verb">device_code</spanx> has expired. The client will need to make a new
           Device Authorization Request.</t>

  </list> 
  </t>

  <t>The error codes <spanx style="verb">authorization_pending</spanx> and
    <spanx style="verb">slow_down</spanx> are considered soft errors. The client
    should continue to poll the token endpoint by repeating the Device
    Token Request (<xref target="TokenRequest" />) when receiving soft errors,
    increasing the poll interval if a <spanx style="verb">slow_down</spanx> error
    is received. Other error codes are considered hard errors, the client should
    stop polling and react accordingly, for example, by displaying an error to
    the user.
  </t>

  <t>
    The interval at which the client polls MUST NOT be more frequent than the
    <spanx style="verb">interval</spanx> parameter returned in the Device Authorization
    Response (see <xref target="AuthorizationResponse"/>).
  </t>

  <t>
  The assumption of this specification is that the secondary device the
  user is authorizing the request on does not have a way to communicate back
  to the OAuth client. That only a one-way channel is required makes this flow
  useful in many scenarios such as a HTML application on TV that can only 
  make outbound requests. If a return channel were to exist for the chosen user
  interaction interface, then the device MAY wait until notified on that channel
  that the user has completed the action before initiating the token request.
  Such behavior however is outside the scope of this specification.
  </t>

  </section>


    </section> 

    <section anchor="Discovery" title="Discovery Metadata">
      <t>
        Support for the device flow MAY be declared in the OAuth 2.0
        Authorization Server Metadata <xref target="I-D.ietf-oauth-discovery"/>
        with the following metadata:
      </t>
      <t>
      <list style="hanging"> 
        <t hangText="device_authorization_endpoint">
          <vspace/>
          OPTIONAL.
          URL of the authorization server's device authorization endpoint 
          defined in <xref target="AuthorizationRequest"/>.
        </t>
      </list>
      </t>
    </section>

    <section anchor="Security" title="Security Considerations">
        <section title="User Code Brute Forcing" anchor="UserCodeBruteForce">
          <t>
          Since the user code is typed by the user, the entropy is typically
          less than would be used for the device code or other OAuth bearer token types.
          It is therefore recommended that the server rate-limit user code
          attempts. The user code SHOULD have enough entropy that when combined
          with rate limiting makes a brute-force attack infeasible.
          </t>
        </section>
        <section title="Device Trustworthiness" anchor="DeviceTrustworthiness">
          <t>
          Unlike other native application OAuth 2.0 flows, the device requesting the
          authorization is not the same as the device that the user grants access
          from. Thus, signals from the approving user's session and device are
          not relevant to the trustworthiness of the client device.
          </t>
        </section>
        <section title="Remote Phishing" anchor="RemotePhishing">
          <t>
          It is possible for the device flow to be initiated on a device in
          an attacker's possession. For example, they might send an email
          instructing the target user to visit the verification URL and
          enter the user code. To mitigate such an attack it is RECOMMENDED
          during the User Instruction (<xref target="UserInstruction"/>)
          to inform the user that they are authorizing a device, and to confirm
          that the device is in their possession.
          </t>
          <t>
          The user code needs to have a long enough lifetime to be useable (allowing
          the user to retrieve their secondary device, navigate to the verification URI, login, etc),
          but should be sufficiently short to limit the
          usability of a code obtained for phishing. This doesn't prevent a
          phisher presenting a fresh token, particularly in the case they
          are interacting with the user in real time, 
          but it does limit the viability of codes sent over email or SMS.
          </t> 
        </section>
        <section title="Non-confidential Clients" anchor="NonConfidentialClient">
          <t>
          Most device clients are incapable of being confidential clients, as secrets
          that are statically included as part of an app distributed to
          multiple users cannot be considered confidential.
          For such clients, the recommendations of 
          Section 5.3.1 of <xref target="RFC6819" /> and
          Section 8.9 of <xref target="I-D.ietf-oauth-native-apps"/> apply.
          </t>
        </section>
        <section title="Non-Visual Code Transmission" anchor="NonVisualCodeTransmission">
          <t>
          There is no requirement that the user code be displayed by the
          device visually. Other methods of one-way communication can potentially be
          used, such as text-to-speech audio, or Bluetooth LE. To mitigate an attack
          where a malicious user can bootstrap their credentials on a device
          not in their control, it is RECOMMENDED that any chosen communication 
          channel only be accessible by people in close proximity. E.g., users
          who can see, or hear the device, or within range of a short-range
          wireless signal.
          </t>
        </section>

    </section>

    <section anchor="Usability" title="Usability Considerations">
      <t>
        This section is a non-normative discussion of usability considerations.
      </t>
      
      <section anchor="UserCodeRecommendations" title="User Code Recommendations">
        <t>
          For many users, their nearest internet-connected device will be their
          mobile phone, and typically these devices offer input methods that are
          more time consuming than a computer keyboard to change the case or
          input numbers. To improve usability (improving entry speed, and
          reducing retries), these limitations should be taken into account
          when selecting the user-code character set.
        </t>
        <t>
          One way to improve input speed is to restrict the character set to
          case-insensitive A-Z characters, with no digits. These characters can
          typically be input on a mobile keyboard without using modifier keys.
          Further removing the I and O characters due to potential confusion
          with numbers results in the base-24 character set:
          <spanx style="verb">ABCDEFGHJKLMNPQRSTUVWXYZ</spanx>. Dashes or other
          punctuation may be included for readability.
        </t>
        <t>
          An example user code
          following this guideline, with 24^8 bits of entropy,
          is <spanx style="verb">WDJB-MJHT</spanx>.
        </t>
        <t>
          The server should ignore any characters like punctuation that are
          not in the user-code character set. Provided that the character set doesn't include
          characters of different case, the comparison should be case insensitive.
        </t>
      </section>
    </section>

    <section anchor="IANA" title="IANA Considerations">

      <section anchor="URIReg" title="OAuth URI Registration">

        <t>
          This specification registers the following values in the
          IANA "OAuth URI" registry
          <xref target="IANA.OAuth.Parameters"/>
          established by <xref target="RFC6755"/>.
        </t>

        <section title="Registry Contents" anchor="URIContents">

          <t>
            <?rfc subcompact="yes"?>
            <list style="symbols">
              <t>URN: urn:ietf:params:oauth:grant-type:device_code</t>
              <t>Common Name: Device flow grant type for OAuth 2.0</t>
              <t>Change controller: IESG</t>
              <t>Specification Document: <xref target="AuthorizationRequest"/> of [[ this specification ]]</t>
            </list>
          </t>

          <?rfc subcompact="no"?>

        </section>
      </section>

      <section anchor="ErrorReg" title="OAuth Extensions Error Registration">

        <t>
          This specification registers the following values in the
          IANA "OAuth Extensions Error Registry" registry
          <xref target="IANA.OAuth.Parameters"/>
          established by <xref target="RFC6749"/>.
        </t>

        <section title="Registry Contents" anchor="ErrorContents">
          <t>
            <?rfc subcompact="yes"?>
            <list style="symbols">
              <t>Error name: authorization_pending</t>
              <t>Error usage location: Token endpoint response</t>
              <t>Related protocol extension: [[ this specification ]]</t>
              <t>Change controller: IETF</t>
              <t>Specification Document: <xref target="TokenResponse"/> of [[ this specification ]]</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style="symbols">
              <t>Error name: slow_down</t>
              <t>Error usage location: Token endpoint response </t>
              <t>Related protocol extension: [[ this specification ]]</t>
              <t>Change controller: IETF</t>
              <t>Specification Document: <xref target="TokenResponse"/> of [[ this specification ]]</t>
            </list>
          </t>
          <t>
            <?rfc subcompact="yes"?>
            <list style="symbols">
              <t>Error name: expired_token</t>
              <t>Error usage location: Token endpoint response </t>
              <t>Related protocol extension: [[ this specification ]]</t>
              <t>Change controller: IETF</t>
              <t>Specification Document: <xref target="TokenResponse"/> of [[ this specification ]]</t>
            </list>
          </t>

          <?rfc subcompact="no"?>

        </section>
      </section>

      <section title="OAuth 2.0 Authorization Server Metadata" anchor="MetadataReg">

        <t>
          This specification registers the following values in the
          IANA "OAuth 2.0 Authorization Server Metadata" registry
          <xref target="IANA.OAuth.Parameters"/>
          established by <xref target="I-D.ietf-oauth-discovery"/>.
        </t>

        <section title="Registry Contents" anchor="MetadataContents">
          <t>
            <?rfc subcompact="yes"?>
            <list style="symbols">
              <t>Metadata name: device_authorization_endpoint</t>
              <t>Metadata Description: The Device Authorization Endpoint.</t>
              <t>Change controller: IESG</t>
              <t>Specification Document: <xref target="Discovery"/> of [[ this specification ]]</t>
            </list>
          </t>

          <?rfc subcompact="no"?>

        </section>
      </section>

    </section>

  </middle>

  <back>

    <references title='Normative References'>

      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-oauth-discovery-05.xml'?>
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.draft-ietf-oauth-native-apps-07.xml'?>
      <?rfc include="reference.RFC.2119"?>
      <?rfc include="reference.RFC.6749"?>
      <?rfc include="reference.RFC.6755"?>
      <?rfc include="reference.RFC.6819"?>
      <reference anchor="IANA.OAuth.Parameters" target="http://www.iana.org/assignments/oauth-parameters">
        <front>
          <title>OAuth Parameters</title>
          <author>
            <organization>IANA</organization>
          </author>
    <date/>
        </front>
      </reference>
    </references>

    <section anchor="Acknowledgements" title="Acknowledgements">

      <t>
	The -00 version of this document was based on draft-recordon-oauth-v2-device
	edited by David Recordon and Brent Goldman. The content of that document 
	was initially part of the OAuth 2.0 protocol specification but was later 
	removed due to the lack of sufficient deployment expertise at that time.
	We would therefore also like to thank the OAuth working group for their
	work on the initial content of this specification through 2010.
      </t>

    </section>

    <section anchor="History" title="Document History">
      <?rfc subcompact="yes"?>
      <t>
	[[ to be removed by the RFC Editor before publication as an RFC ]]
      </t>

      <t>
        -04
        <list style='symbols'>
          <t>
            Security &amp; Usability sections. OAuth Discovery Metadata.
          </t>
        </list>
      </t>

      <t>
        -03
        <list style='symbols'>
          <t>
            device_code is now a URN.
            Added IANA Considerations
          </t>
        </list>
      </t>

      <t>
        -02
        <list style='symbols'>
          <t>
            Added token request &amp; response specification. 
          </t>
        </list>
      </t>

      <t>
        -01
        <list style='symbols'>
          <t>
            Applied spelling and grammar corrections and added the Document History appendix.
          </t>
        </list>
      </t>

      <t>
        -00
        <list style='symbols'>
          <t>
            Initial working group draft based on draft-recordon-oauth-v2-device.
	  </t>
        </list>
      </t>
      <?rfc subcompact="no"?>
    </section>     

  </back>
</rfc>
